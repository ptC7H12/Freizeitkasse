import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';
import '../../data/database/app_database.dart';
import '../../providers/task_provider.dart';
import '../../providers/current_event_provider.dart';
import '../../utils/constants.dart';
import '../../widgets/responsive_scaffold.dart';
import '../../widgets/adaptive_list_item.dart';
import '../../extensions/context_extensions.dart';
import 'task_form_screen.dart';
import 'auto_tasks_screen.dart';

class TasksScreen extends ConsumerStatefulWidget {
  const TasksScreen({super.key});

  @override
  ConsumerState<TasksScreen> createState() => _TasksScreenState();
}

class _TasksScreenState extends ConsumerState<TasksScreen> with SingleTickerProviderStateMixin {
  String _selectedTab = 'all'; // 'all', 'pending', 'completed', 'overdue'
  late TabController _tabController;

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 2, vsync: this);
    _tabController.addListener(() {
      setState(() {}); // Rebuild when tab changes to show/hide FAB
    });
  }

  @override
  void dispose() {
    _tabController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final currentEvent = ref.watch(currentEventProvider);
    final autoTasksAsync = ref.watch(autoGeneratedTasksProvider);

    if (currentEvent == null) {
      return const ResponsiveScaffold(
        title: 'Aufgaben',
        selectedIndex: 9,
        body: Center(child: Text('Bitte wählen Sie zuerst eine Veranstaltung aus.')),
      );
    }

    // Calculate total auto tasks count for badge
    final totalAutoTasks = autoTasksAsync.whenData((tasks) =>
      tasks.values.fold<int>(0, (sum, list) => sum + list.length)
    ).value ?? 0;

    return ResponsiveScaffold(
      title: 'Aufgaben',
      selectedIndex: 9,
      body: Column(
        children: [
          // Tab Bar
          TabBar(
            controller: _tabController,
            tabs: [
              Tab(
                icon: totalAutoTasks > 0
                    ? Badge(
                        label: Text('$totalAutoTasks'),
                        child: const Icon(Icons.auto_awesome),
                      )
                    : const Icon(Icons.auto_awesome),
                text: 'Automatisch',
              ),
              const Tab(
                icon: Icon(Icons.edit_note),
                text: 'Manuell',
              ),
            ],
          ),

          // Tab Views
          Expanded(
            child: TabBarView(
              controller: _tabController,
              children: [
                // Auto Tasks Tab
                const AutoTasksScreen(),

                // Manual Tasks Tab
                _buildManualTasksTab(),
              ],
            ),
          ),
        ],
      ),
      floatingActionButton: _tabController.index == 1
          ? FloatingActionButton.extended(
              onPressed: () => _navigateToTaskForm(context),
              icon: const Icon(Icons.add),
              label: const Text('Aufgabe'),
            )
          : null,
    );
  }

  Widget _buildManualTasksTab() {
    final tasksAsync = ref.watch(tasksProvider);
    final statsAsync = ref.watch(taskStatisticsProvider);

    return Column(
      children: [
        // Statistics Card
        statsAsync.when(
          data: (stats) => Card(
            margin: AppConstants.paddingAll16,
            child: Padding(
              padding: AppConstants.paddingAll16,
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceAround,
                children: [
                  _buildStatItem(Icons.list_alt, 'Gesamt', '${stats['total']}', Colors.blue),
                  _buildStatItem(Icons.pending, 'Offen', '${stats['pending']}', Colors.orange),
                  _buildStatItem(Icons.check_circle, 'Erledigt', '${stats['completed']}', Colors.green),
                  if ((stats['overdue'] as int) > 0)
                    _buildStatItem(Icons.warning, 'Überfällig', '${stats['overdue']}', Colors.red),
                ],
              ),
            ),
          ),
          loading: () => const SizedBox.shrink(),
          error: (_, __) => const SizedBox.shrink(),
        ),

        // Filter Tabs
        SingleChildScrollView(
          scrollDirection: Axis.horizontal,
          padding: const EdgeInsets.symmetric(horizontal: 16),
          child: Row(
            children: [
              _buildFilterChip('Alle', 'all'),
              _buildFilterChip('Offen', 'pending'),
              _buildFilterChip('Erledigt', 'completed'),
              _buildFilterChip('Überfällig', 'overdue'),
            ],
          ),
        ),
        const SizedBox(height: AppConstants.spacingS),

        // Tasks List
        Expanded(
          child: tasksAsync.when(
            data: (tasks) {
              final filteredTasks = _filterTasks(tasks);
              if (filteredTasks.isEmpty) {
                return Center(
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Icon(Icons.task_alt, size: 80, color: Colors.grey[400]),
                      const SizedBox(height: AppConstants.spacing),
                      Text('Keine Aufgaben', style: TextStyle(color: Colors.grey[600])),
                    ],
                  ),
                );
              }

              return ListView.builder(
                padding: AppConstants.paddingAll16,
                itemCount: filteredTasks.length,
                itemBuilder: (context, index) {
                  final task = filteredTasks[index];
                  final isOverdue = task.status == 'pending' && (task.dueDate?.isBefore(DateTime.now()) ?? false);

                  return AdaptiveListItem(
                    leading: Icon(
                      task.status == 'completed' ? Icons.check_circle : Icons.radio_button_unchecked,
                      color: task.status == 'completed' ? Colors.green : (isOverdue ? Colors.red : Colors.grey),
                    ),
                    title: Text(
                      task.title,
                      style: TextStyle(
                        decoration: task.status == 'completed' ? TextDecoration.lineThrough : null,
                        fontWeight: FontWeight.w500,
                      ),
                    ),
                    subtitle: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        if (task.description != null)
                          Text(task.description!, maxLines: 1, overflow: TextOverflow.ellipsis),
                        if (task.dueDate != null)
                          Row(
                            children: [
                              Icon(Icons.calendar_today, size: 12, color: isOverdue ? Colors.red : Colors.grey),
                              const SizedBox(width: 4),
                              Text(
                                'Fällig: ${DateFormat('dd.MM.yyyy', 'de_DE').format(task.dueDate!)}',
                                style: TextStyle(
                                  color: isOverdue ? Colors.red : null,
                                  fontSize: 12,
                                ),
                              ),
                            ],
                          ),
                      ],
                    ),
                    onTap: () => _navigateToTaskForm(context, task),
                    onEdit: () => _navigateToTaskForm(context, task),
                    onDelete: () async {
                      final repo = ref.read(taskRepositoryProvider);
                      await repo.deleteTask(task.id);
                      if (context.mounted) {
                        context.showSuccess('Aufgabe gelöscht');
                      }
                    },
                    deleteConfirmMessage: 'Aufgabe "${task.title}" wirklich löschen?',
                  );
                },
              );
            },
            loading: () => const Center(child: CircularProgressIndicator()),
            error: (e, _) => Center(child: Text('Fehler: $e')),
          ),
        ),
      ],
    );
  }

  Widget _buildStatItem(IconData icon, String label, String value, Color color) {
    return Column(
      children: [
        Icon(icon, color: color),
        const SizedBox(height: 4),
        Text(value, style: TextStyle(fontWeight: FontWeight.bold, fontSize: 18, color: color)),
        Text(label, style: TextStyle(fontSize: 12, color: Colors.grey[600])),
      ],
    );
  }

  Widget _buildFilterChip(String label, String value) {
    return Padding(
      padding: const EdgeInsets.only(right: 8),
      child: FilterChip(
        label: Text(label),
        selected: _selectedTab == value,
        onSelected: (selected) => setState(() => _selectedTab = value),
      ),
    );
  }

  List<Task> _filterTasks(List<Task> tasks) {
    final now = DateTime.now();
    switch (_selectedTab) {
      case 'pending':
        return tasks.where((t) => t.status == 'pending').toList();
      case 'completed':
        return tasks.where((t) => t.status == 'completed').toList();
      case 'overdue':
        return tasks.where((t) => t.status == 'pending' && (t.dueDate?.isBefore(now) ?? false)).toList();
      default:
        return tasks;
    }
  }

  void _navigateToTaskForm(BuildContext context, [Task? task]) {
    Navigator.of(context).push(
      MaterialPageRoute(
        builder: (context) => TaskFormScreen(taskId: task?.id),
      ),
    );
  }
}
