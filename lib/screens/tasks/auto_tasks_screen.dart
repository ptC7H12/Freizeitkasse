import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../providers/task_provider.dart';
import '../../providers/expense_provider.dart';
import '../../providers/payment_provider.dart';
import '../../providers/participant_provider.dart';
import '../../providers/current_event_provider.dart';
import '../../services/auto_task_generator_service.dart';
import '../../utils/constants.dart';
import '../../utils/logger.dart';
import '../../extensions/context_extensions.dart';

class AutoTasksScreen extends ConsumerWidget {
  const AutoTasksScreen({super.key});

  // Task type translations and icons
  static const Map<String, Map<String, dynamic>> _taskTypeConfig = {
    'bildung_teilhabe': {
      'title': 'Bildung & Teilhabe',
      'icon': Icons.school,
      'color': Colors.blue,
    },
    'expense_reimbursement': {
      'title': 'Ausgaben-Erstattung',
      'icon': Icons.receipt,
      'color': Colors.orange,
    },
    'outstanding_payments': {
      'title': 'Ausstehende Zahlungen',
      'icon': Icons.payment,
      'color': Colors.amber,
    },
    'manual_price_override': {
      'title': 'Manuelle Preisanpassungen',
      'icon': Icons.edit,
      'color': Colors.purple,
    },
    'overdue_payments': {
      'title': '√úberf√§llige Zahlungen',
      'icon': Icons.warning,
      'color': Colors.red,
    },
    'income_subsidy_mismatch': {
      'title': 'Zuschuss-Differenzen (Rollen)',
      'icon': Icons.error_outline,
      'color': Colors.deepOrange,
    },
    'family_subsidy_mismatch': {
      'title': 'Kinderzuschuss-Differenzen',
      'icon': Icons.family_restroom,
      'color': Colors.teal,
    },
    'role_count_exceeded': {
      'title': 'Rollen√ºberschreitungen',
      'icon': Icons.group,
      'color': Colors.indigo,
    },
    'birthday_gifts': {
      'title': 'Geschenke f√ºr Geburtstagskinder',
      'icon': Icons.cake,
      'color': Colors.pink,
    },
    'kitchen_team_gift': {
      'title': 'Geschenk f√ºr K√ºchenteam',
      'icon': Icons.restaurant,
      'color': Colors.green,
    },
    'familienfreizeit_non_member_check': {
      'title': 'Familienfreizeit-Pr√ºfung',
      'icon': Icons.info,
      'color': Colors.blueGrey,
    },
  };

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final autoTasksAsync = ref.watch(autoGeneratedTasksProvider);

    return autoTasksAsync.when(
      data: (taskGroups) {
        final totalTasks = taskGroups.values.fold<int>(0, (sum, list) => sum + list.length);

        if (totalTasks == 0) {
          return Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(Icons.check_circle_outline, size: 80, color: Colors.green[300]),
                const SizedBox(height: AppConstants.spacing),
                Text(
                  'Keine automatischen Aufgaben',
                  style: TextStyle(fontSize: 18, color: Colors.grey[600]),
                ),
                const SizedBox(height: AppConstants.spacingS),
                Text(
                  'Alle Aufgaben erledigt! üéâ',
                  style: TextStyle(color: Colors.grey[500]),
                ),
              ],
            ),
          );
        }

        return ListView(
          padding: AppConstants.paddingAll16,
          children: taskGroups.entries
              .where((entry) => entry.value.isNotEmpty)
              .map((entry) => _buildTaskGroup(context, ref, entry.key, entry.value))
              .toList(),
        );
      },
      loading: () => const Center(child: CircularProgressIndicator()),
      error: (e, stack) {
        AppLogger.error('Error loading auto tasks', error: e, stackTrace: stack);
        return Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Icon(Icons.error_outline, size: 80, color: Colors.red[300]),
              const SizedBox(height: AppConstants.spacing),
              Text('Fehler beim Laden der Aufgaben', style: TextStyle(color: Colors.grey[600])),
              const SizedBox(height: AppConstants.spacingS),
              TextButton(
                onPressed: () => ref.refresh(autoGeneratedTasksProvider),
                child: const Text('Erneut versuchen'),
              ),
            ],
          ),
        );
      },
    );
  }

  Widget _buildTaskGroup(
    BuildContext context,
    WidgetRef ref,
    String taskType,
    List<GeneratedTask> tasks,
  ) {
    final config = _taskTypeConfig[taskType] ?? {
      'title': taskType,
      'icon': Icons.task,
      'color': Colors.grey,
    };

    return Card(
      margin: const EdgeInsets.only(bottom: AppConstants.spacing),
      child: ExpansionTile(
        leading: Icon(config['icon'] as IconData, color: config['color'] as Color),
        title: Text(
          config['title'] as String,
          style: const TextStyle(fontWeight: FontWeight.bold),
        ),
        subtitle: Text('${tasks.length} Aufgabe(n)'),
        children: tasks.map((task) => _buildTaskItem(context, ref, task)).toList(),
      ),
    );
  }

  Widget _buildTaskItem(BuildContext context, WidgetRef ref, GeneratedTask task) {
    return ListTile(
      leading: Icon(
        _getPriorityIcon(task.priority),
        color: _getPriorityColor(task.priority),
      ),
      title: Text(task.title),
      subtitle: Text(task.description, maxLines: 2, overflow: TextOverflow.ellipsis),
      trailing: IconButton(
        icon: const Icon(Icons.check_circle_outline, color: Colors.green),
        tooltip: 'Als erledigt markieren',
        onPressed: () => _completeTask(context, ref, task),
      ),
      onTap: () => _showTaskDetails(context, ref, task),
    );
  }

  IconData _getPriorityIcon(String priority) {
    switch (priority.toLowerCase()) {
      case 'high':
        return Icons.priority_high;
      case 'medium':
        return Icons.adjust;
      case 'low':
        return Icons.low_priority;
      default:
        return Icons.circle;
    }
  }

  Color _getPriorityColor(String priority) {
    switch (priority.toLowerCase()) {
      case 'high':
        return Colors.red;
      case 'medium':
        return Colors.orange;
      case 'low':
        return Colors.blue;
      default:
        return Colors.grey;
    }
  }

  void _showTaskDetails(BuildContext context, WidgetRef ref, GeneratedTask task) {
    showDialog<void>(
      context: context,
      builder: (context) => AlertDialog(
        title: Text(task.title),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(task.description),
            if (task.dueDate != null) ...[
              const SizedBox(height: AppConstants.spacing),
              Row(
                children: [
                  const Icon(Icons.calendar_today, size: 16),
                  const SizedBox(width: 4),
                  Text('F√§llig: ${task.dueDate!.day}.${task.dueDate!.month}.${task.dueDate!.year}'),
                ],
              ),
            ],
            const SizedBox(height: AppConstants.spacing),
            Row(
              children: [
                Icon(_getPriorityIcon(task.priority), size: 16, color: _getPriorityColor(task.priority)),
                const SizedBox(width: 4),
                Text('Priorit√§t: ${task.priority}'),
              ],
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Schlie√üen'),
          ),
          FilledButton.icon(
            onPressed: () {
              Navigator.pop(context);
              _completeTask(context, ref, task);
            },
            icon: const Icon(Icons.check),
            label: const Text('Als erledigt markieren'),
          ),
        ],
      ),
    );
  }

  Future<void> _completeTask(BuildContext context, WidgetRef ref, GeneratedTask task) async {
    try {
      final taskRepo = ref.read(taskRepositoryProvider);
      final currentEvent = ref.read(currentEventProvider);

      if (currentEvent == null) {
        if (context.mounted) {
          context.showError('Kein Event ausgew√§hlt');
        }
        return;
      }

      // Mark task as completed
      await taskRepo.completeTask(
        eventId: currentEvent.id,
        taskType: task.taskType,
        referenceId: task.referenceId,
      );

      // Special handling for specific task types
      await _handleTaskCompletion(context, ref, task);

      // Refresh auto tasks
      ref.invalidate(autoGeneratedTasksProvider);

      if (context.mounted) {
        context.showSuccess('Aufgabe als erledigt markiert');
      }
    } catch (e, stack) {
      AppLogger.error('Error completing task', error: e, stackTrace: stack);
      if (context.mounted) {
        context.showError('Fehler beim Markieren der Aufgabe');
      }
    }
  }

  Future<void> _handleTaskCompletion(
    BuildContext context,
    WidgetRef ref,
    GeneratedTask task,
  ) async {
    final expenseRepo = ref.read(expenseRepositoryProvider);
    final paymentRepo = ref.read(paymentRepositoryProvider);
    final participantRepo = ref.read(participantRepositoryProvider);
    final currentEvent = ref.read(currentEventProvider);

    if (currentEvent == null) {
      return;
    }

    // Special handling for expense_reimbursement
    if (task.taskType == 'expense_reimbursement') {
      await expenseRepo.updateExpense(
        id: task.referenceId,
        reimbursed: true,
      );
      AppLogger.info('Marked expense ${task.referenceId} as reimbursed');
    }

    // Special handling for outstanding_payment / overdue_payment
    if (task.taskType == 'outstanding_payment' || task.taskType == 'overdue_payment') {
      final participant = await participantRepo.getParticipantById(task.referenceId);

      if (participant != null) {
        final finalPrice = participant.manualPriceOverride ?? participant.calculatedPrice;
        final totalPaid = await paymentRepo.getTotalPaymentsForParticipant(participant.id);
        final outstanding = finalPrice - totalPaid;

        if (outstanding > 0.01) {
          // Automatically create payment
          await paymentRepo.createPayment(
            eventId: currentEvent.id,
            participantId: participant.id,
            amount: outstanding,
            paymentDate: DateTime.now(),
            paymentMethod: 'Automatisch',
            referenceNumber: 'Aufgabe erledigt: ${participant.firstName} ${participant.lastName}',
            notes: 'Zahlungseingang automatisch aus erledigter Aufgabe erstellt',
          );

          AppLogger.info('Automatically created payment of ${outstanding.toStringAsFixed(2)}‚Ç¨ for participant ${participant.id}');
        }
      }
    }
  }
}
